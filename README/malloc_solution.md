# CSAPP  malloc lab实现思路
## 要求梳理
文档要求实现一个双字对齐的分配器，主要就是要求实现他给出的以下函数:
```C
int   mm_init(void);                       // 初始化
void *mm_malloc(size_t size);              // 分配堆中空间并返回一个指针
void  mm_free(void *ptr);                  // 释放空间
void *mm_realloc(void *ptr, size_t size);  // 改变指针所指的旧块大小
```
然后文档中列了几点要求：
+ 不能调用库函数
+ 不允许定义任何全局或静态的复合数据结构，例如arrays、lists、structs等
+ 分配器必须始终返回与8字节边界对齐的指针

当然只靠它给的四个函数是无法是实现分配器的，所以我们还要定义宏和辅助函数，当然它也给出了一些可调用的辅助函数，如下：
```c
void  *mem sbrk(int incr);                 // 扩展和收缩堆
void  *mem heap lo(void);                  // 堆顶指针
void  *mem heap hi(void);                  // 堆底指针
size_t mem heapsize(void);                 // 堆目前大小
size_t mem pagesize(void);                 // 返回系统的页面大小（字节）（在Linux中为4K）。
```
## 知识回顾
讲到这的话，我们就先来回顾一下`堆`相关的知识
### 堆与虚拟内存
+ 每个linux进程都有属于自己的单独的虚拟地址空间，主要分为栈、共享库、堆以及.bss文件（未初始化）和.data文件（已初始化）还有代码段
+ 分配器是将堆视为一组不同大小的`块（block）`的集合来维护，每个块就是一个连续的`虚拟内存片（chunk）`，要么是已分配的，要么是空闲的，空闲块可用来分配
+ 堆是通过malloc函数（显式分配器）实现分配内存的，堆的内存并不像栈一样会被系统释放，堆通过mallo函数所分配的内存需要手动释放，如果存在过多已经不再使用的堆内存没有被释放的话，会导致堆内存溢出
![虚拟内存图片](images/b.png)

### 堆块的格式
考虑到堆块合并问题，我们此处选择`带边界标记的堆块`格式
+ 由三部分构成，头部、有效载荷和填充、脚部
+ 头部和脚部均表示块大小，且脚部与下一块的头部只差一字
+ 由于是8字节对齐，后三位均为0，最后一位表示当前块是已分配还是空闲的
![堆块图片](images/d.png)

### 块序列
1. 隐式空闲链表
2. 显式空闲链表
3. 分离的空闲链表
两种基本方法：
+ 简单分离存储
+ 分离适配

### 放置策略选择
1. 首次适配
+ 需从头开始搜索链表从而找到合适的空闲块，时间过长
+ 易将大的空闲块保留在链表后面，也易导致起始处出现过多`小碎片（外部碎片）`
2. 下一次适配
+ 时间比首次适配快，但内存利用率低得多
3. 最佳适配
+ 内存利用率高，但容易出现对堆进行彻底的搜索的情况

## 基本思路
我们主要就是考虑选择什么样的块序列及放置策略

书上给出了基于`隐式空闲链表`，使用`立即边界标记合并`方式，选择`首次适配`的策略实现了一个简单分配器，我们来看一下代码：
```c

```
### 隐式空闲链表
### 分离的空闲链表
## 具体代码
### 隐式空闲链表
[完整代码见仓库](https://github.com/qaok/csapp/blob/master/malloclab/malloclab-handout/mm.c)
### 分离的空闲链表
[完整代码见仓库](https://github.com/qaok/csapp/blob/master/malloclab/malloclab-handout/mm.c)
## 代码测试
### 隐式空闲链表
### 分离的空闲链表
